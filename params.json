{"name":"ParaphraseAGH","tagline":"","body":"### Welcome to the Paraphrase AGH project.\r\n\r\nThe goal of this project is to help creating highly-concurrent multi-agent systems targeted at massively multicore hardware. The Paraphrase AGH project is part of the more general [Paraphrase](http://paraphrase-ict.eu/) research project. \r\n\r\n### Why we do this\r\n\r\n#### Efficiency\r\n\r\nMost multi-agent software come into two categories:\r\n\r\n* Heavy-grained agent programming (e.g. Jade), where every agent runs in a separate thread,\r\n* Fine-grained agent simulations (e.g. Netlogo), where the whole agent population is thread-contained.\r\n\r\nThe first approach is not efficient in computationally intensive simulations with large numbers of agents. [see TODOpaperRef] The second does not make use of the growing parallel capabilities of modern hardware. \r\n\r\nWe want to fill the gap and allow fine-grained agent-based simulations and computations which could be run efficiently on massively multicore hardware.\r\n\r\n#### Ease of use\r\n\r\nWriting a concurrent application is hard for most programmers. Writing a concurrent agent simulation is even harder. Moreover, most of the existing software tighly couples the agent programming model to the underlying execution model and parallelism type.\r\n\r\nWe want programmers to be able to design a multi-agent system at a high level which abstracts of the actual execution model. Then, such high level multi-agent patterns could be mapped to match a specific hardware by using the most adequate execution model for that hardware.\r\n\r\nIn consequence, multi-agent simulations and computations could be easily designed and tested and the same design could then be scaled out along with additional resources to solve harder problems or run bigger simulations.\r\n\r\n\r\n### How we do this\r\n\r\n#### Multi-agent patterns\r\n\r\nWe use high-level functional patterns to design multi-agent algorithms in a way similar to the MapReduce model.\r\n\r\nThe multi-agent system is decomposed into:\r\n\r\n##### The mapping part\r\nwhich includes:\r\n\r\n* Agent **state** (and possibly location in spatial simulations)\r\n* Agent **action**\r\n* Agent **behaviour**, .i.e. a function of agent state into agent action\r\n\r\n`behaviour: (State, Location) -> (Action, Location)`\r\n\r\nDuring the exection of the multi-agent system, agents will repeatedly choose an action to be performed in some location based on their current state and location.\r\n\r\n\r\n##### The reducing part:\r\n\r\nAgents are repeatedly grouped by similar actions and location. For every such group a **meetings** is performed.\r\nMeeting are defined as having some given arity - the group of reduced agents is subdivided into smaller groups of that arity and for each such smaller group the meeting function is called, which yields a new sequence of agents as the result of the meeting. \r\n\r\n`meeting: (Action, Location, [State]) -> [(State, Location)]`\r\n\r\nAgents may interact during the meetings or act individually - it follows the arity of the meeting function, which is problem-dependent.\r\n\r\nThe resulting sequence of agents may contain previous agents with updated state, or new agents. Existing agents may also be dropped from the resulting list, effectively removing them from the system.\r\n\r\nThe results of the meetings are combined to yield subsequent populations.\r\n\r\n#### Architecture\r\n\r\nA multi-agent simulation is then fully defined by the space of possible agent states, the set of possible actions and a behaviour and meetings functions.\r\n\r\nAll that remains is to combine these functions to run a multi-agent simulation. We provide several ways to do this. They will be described here soon.\r\n\r\n### Authors and Contributors\r\n2013-2014\r\nDaniel Krzywicki\r\nJan Stypka\r\nPiotr Anielski","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}